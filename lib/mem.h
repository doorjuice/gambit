/* File: "mem.h" */

/* Copyright (c) 1994-2013 by Marc Feeley, All Rights Reserved. */

#ifndef ___MEM_H
#define ___MEM_H


/*
 * Memory allocation parameters:
 *
 * ___MAX_NB_PARMS is the maximum number of formal parameters of procedures.
 *
 * ___MAX_NB_ARGS is the maximum number of arguments (actual parameters)
 * that are passed to procedures.  It must be >= ___MAX_NB_PARMS.
 *
 * ___MAX_NB_FRAME_SLOTS is the maximum number of slots in continuation
 * frames.  It must be >= ___MAX_NB_ARGS.
 *
 * ___MSECTION_SIZE is the size in words of sections that contain
 * movable objects (msections).
 *
 * ___MSECTION_FUDGE is the size in words of the msection fudge area.
 * There is a fudge area at the end of the space reserved for
 * allocating movable objects (heap fudge) and a fudge area at the end
 * of the space reserved for allocating continuation frames (stack
 * fudge).  Instructions in the code generated by the compiler check
 * whether the heap allocation pointer points into the heap fudge area
 * after a bounded number of constant size allocations and whether the
 * frame pointer points into the stack fudge area.  When either of
 * these cases occur, the assignment of space for the heap and stack
 * is adjusted.  If there is less than or equal to ___MSECTION_WASTE
 * words of space left, a garbage collection is triggered.
 * ___MSECTION_FUDGE must be >=
 * ___MAX_NB_FRAME_SLOTS+1+___SUBTYPED_OVERHEAD (which is the size of
 * the largest continuation frame).
 *
 * ___MSECTION_BIGGEST is the size in words beyond which an object will
 * be allocated as a still object.  It must be <= ___MSECTION_FUDGE.
 *
 * ___MIN_NB_MSECTIONS is the minimum number of msections contained
 * in the heap.
 *
 * ___PSECTION_SIZE is the size in words of sections that contain permanent
 * objects (psections).
 *
 * ___PSECTION_WASTE is the maximum number of words that are unused
 * in a psection due to fragmentation.  It must be <= ___PSECTION_SIZE.
 *
 * ___DEFAULT_LIVE_PERCENT is the default percentage of the heap that
 * is live after a GC.  At the end of a GC the heap is resized to reach
 * this percentage.
 */

#define ___MAX_NB_PARMS         1024
#define ___MAX_NB_ARGS          8192
#define ___MAX_NB_FRAME_SLOTS   8192
#define ___MSECTION_SIZE        131072
#define ___MSECTION_FUDGE       (___MAX_NB_FRAME_SLOTS+1+___SUBTYPED_OVERHEAD)
#define ___MSECTION_WASTE       (___MSECTION_FUDGE/16)
#define ___MSECTION_BIGGEST     255
#define ___MIN_NB_MSECTIONS     1
#define ___PSECTION_SIZE        4096
#define ___PSECTION_WASTE       32
#define ___DEFAULT_LIVE_PERCENT 50
#define ___DEFAULT_MIN_HEAP     (1*(1<<20))


/*---------------------------------------------------------------------------*/

#ifdef ___DEBUG

/*
 * Defining the symbol ENABLE_CONSISTENCY_CHECKS will enable the GC to
 * perform checks that detect when the heap is in an inconsistent
 * state.  This is useful to detect bugs in the GC and the rest of the
 * system.  To perform the consistency checks, the verbosity level in
 * ___GSTATE->setup_params.debug_settings must be at least 1.  The checks are
 * very extensive and consequently are expensive.  They should only be
 * used for debugging.
 */
#define ENABLE_CONSISTENCY_CHECKS

/*
 * Defining the symbol GATHER_STATS will cause the GC to gather
 * statistics on the objects it encounters in the heap.
 */
#define GATHER_STATS

/*
 * Defining the symbol SHOW_FRAMES will cause the GC to print out a
 * trace of the continuation frames that are processed.
 */
#undef SHOW_FRAMES

#endif


/*---------------------------------------------------------------------------*/

/* 
 * Initial length of symbol table and keyword table.
 */

#define INIT_SYMBOL_TABLE_LENGTH  2048
#define INIT_KEYWORD_TABLE_LENGTH 128


extern ___SCMOBJ ___setup_mem_pstate
   ___P((___processor_state ___ps,
         ___virtual_machine_state ___vms),
        ());

extern ___SCMOBJ ___setup_mem_vmstate
   ___P((___virtual_machine_state ___vms),
        ());

extern ___SCMOBJ ___setup_mem ___PVOID;

extern void ___cleanup_mem_pstate
   ___P((___processor_state ___ps),
        ());

extern void ___cleanup_mem_vmstate
   ___P((___virtual_machine_state ___vms),
        ());

extern void ___cleanup_mem ___PVOID;


#ifdef ___DEBUG_GARBAGE_COLLECT

#define ___garbage_collect(ps,n) ___garbage_collect_debug (ps,n,__LINE__,__FILE__)

extern ___BOOL ___garbage_collect_debug
   ___P((___PSD
         ___SIZE_TS nonmovable_words_needed,
         int line,
         char *file),
        ());

#else

extern ___BOOL ___garbage_collect
   ___P((___PSD
         ___SIZE_TS nonmovable_words_needed),
        ());

#endif


#ifdef ___DEBUG_STACK_LIMIT

#define ___stack_limit(ps) ___stack_limit_debug (ps,__LINE__,__FILE__)

extern ___BOOL ___stack_limit_debug
   ___P((___PSD
         int line,
         char *file),
        ());

#else

extern ___BOOL ___stack_limit
   ___P((___PSDNC),
        ());

#endif


#ifdef ___DEBUG_HEAP_LIMIT

#define ___heap_limit(ps) ___heap_limit_debug (ps,__LINE__,__FILE__)

extern ___BOOL ___heap_limit_debug
   ___P((___PSD
         int line,
         char *file),
        ());

#else

extern ___BOOL ___heap_limit
   ___P((___PSDNC),
        ());

#endif


extern ___SCMOBJ ___hash_UTF_8_string
   ___P((___UTF_8STRING str),
        ());

extern ___SCMOBJ ___hash_scheme_string
   ___P((___SCMOBJ str),
        ());

extern void ___intern_symkey
   ___P((___SCMOBJ symkey),
        ());

extern ___SCMOBJ ___new_symkey
   ___P((___SCMOBJ name,
         unsigned int subtype),
        ());

extern ___SCMOBJ ___find_symkey_from_UTF_8_string
   ___P((char *str,
         unsigned int subtype),
        ());

extern ___SCMOBJ ___find_symkey_from_scheme_string
   ___P((___SCMOBJ str,
         unsigned int subtype),
        ());

extern ___SCMOBJ ___make_symkey_from_UTF_8_string
   ___P((___UTF_8STRING str,
         unsigned int subtype),
        ());

extern ___SCMOBJ ___make_symkey_from_scheme_string
   ___P((___SCMOBJ str,
         unsigned int subtype),
        ());

extern void ___for_each_symkey
   ___P((unsigned int subtype,
         void (*visit) (___SCMOBJ symkey, void *data),
         void *data),
        ());

#ifdef ___DEBUG

extern ___SCMOBJ ___find_global_var_bound_to
   ___P((___SCMOBJ val),
        ());

#endif

extern ___SCMOBJ ___make_global_var
   ___P((___SCMOBJ sym),
        ());

extern ___F64 ___bytes_allocated
   ___P((___PSDNC),
        ());


/*---------------------------------------------------------------------------*/

#define ___PSTATE_MEM(var) ___ps->mem.var
#define ___VMSTATE_MEM(var) ___VMSTATE_FROM_PSTATE(___ps)->mem.var

#define stack_msection          ___PSTATE_MEM(stack_msection_)
#define alloc_stack_start       ___PSTATE_MEM(alloc_stack_start_)
#define alloc_stack_ptr         ___PSTATE_MEM(alloc_stack_ptr_)
#define alloc_stack_limit       ___PSTATE_MEM(alloc_stack_limit_)
#define heap_msection           ___PSTATE_MEM(heap_msection_)
#define alloc_heap_start        ___PSTATE_MEM(alloc_heap_start_)
#define alloc_heap_ptr          ___PSTATE_MEM(alloc_heap_ptr_)
#define alloc_heap_limit        ___PSTATE_MEM(alloc_heap_limit_)
#define nonexecutable_wills     ___PSTATE_MEM(nonexecutable_wills_)

#define heap_size               ___VMSTATE_MEM(heap_size_)
#define normal_overflow_reserve ___VMSTATE_MEM(normal_overflow_reserve_)
#define overflow_reserve        ___VMSTATE_MEM(overflow_reserve_)
#define words_nonmovable        ___VMSTATE_MEM(words_nonmovable_)
#define words_prev_msections    ___VMSTATE_MEM(words_prev_msections_)
#define still_objs              ___VMSTATE_MEM(still_objs_)
#define still_objs_to_scan      ___VMSTATE_MEM(still_objs_to_scan_)
#define the_msections           ___VMSTATE_MEM(the_msections_)
#define tospace_at_top          ___VMSTATE_MEM(tospace_at_top_)
#define nb_msections_used       ___VMSTATE_MEM(nb_msections_used_)
#define alloc_msection          ___VMSTATE_MEM(alloc_msection_)
#define scan_msection           ___VMSTATE_MEM(scan_msection_)
#define scan_ptr                ___VMSTATE_MEM(scan_ptr_)
#define traverse_weak_refs      ___VMSTATE_MEM(traverse_weak_refs_)
#define reached_gc_hash_tables  ___VMSTATE_MEM(reached_gc_hash_tables_)
#define executable_wills        ___VMSTATE_MEM(executable_wills_)
#define rc_head                 ___VMSTATE_MEM(rc_head_)

#define nb_gcs                  ___VMSTATE_MEM(nb_gcs_)
#define gc_user_time            ___VMSTATE_MEM(gc_user_time_)
#define gc_sys_time             ___VMSTATE_MEM(gc_sys_time_)
#define gc_real_time            ___VMSTATE_MEM(gc_real_time_)
#define bytes_allocated_minus_occupied ___VMSTATE_MEM(bytes_allocated_minus_occupied_)

#define last_gc_user_time       ___VMSTATE_MEM(last_gc_user_time_)
#define last_gc_sys_time        ___VMSTATE_MEM(last_gc_sys_time_)
#define last_gc_real_time       ___VMSTATE_MEM(last_gc_real_time_)
#define last_gc_heap_size       ___VMSTATE_MEM(last_gc_heap_size_)
#define last_gc_alloc           ___VMSTATE_MEM(last_gc_alloc_)
#define last_gc_live            ___VMSTATE_MEM(last_gc_live_)
#define last_gc_movable         ___VMSTATE_MEM(last_gc_movable_)
#define last_gc_nonmovable      ___VMSTATE_MEM(last_gc_nonmovable_)

/* words occupied in heap by movable objects including current msections */
#define WORDS_MOVABLE \
(2*(words_prev_msections + \
(alloc_stack_start - alloc_stack_ptr) + \
(alloc_heap_ptr - alloc_heap_start)))

/* words occupied in heap including current msections */
#define WORDS_OCCUPIED (words_nonmovable + WORDS_MOVABLE)

/* words usable in msections */
#define WORDS_MOVABLE_USABLE \
(2*the_msections->nb_sections*___CAST(___SIZE_TS,((___MSECTION_SIZE>>1)-___MSECTION_FUDGE+1)))

/* words available in heap */
#define WORDS_AVAILABLE \
(words_nonmovable + WORDS_MOVABLE_USABLE - \
overflow_reserve - 2*___MSECTION_FUDGE)


#endif
